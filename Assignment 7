public class Enemy {
    int health;
    int damage;

    public Enemy(int h, int d){
        health = h;
        damage = d;
    }

    void attack(){
        System.out.println("the enemy attacks");
    }
}

public class Goblin extends Enemy{

    //Needs constructor
    public Goblin(int h, int d){
        super(h, d);
    }

    //needs method to overwrite attack in enemy to say "the goblin gobbles" instead of "the enemy attacks
    @Override
//this is how google said to call an override, and it works, so i think this is good
    void attack(){
        System.out.println("the goblin gobbles");
    }
}


public class Wizard extends Enemy{
    String type;
    public Wizard(int h, int d, String t) {
        super(h, d);
        type = t;
    }
    void damageType(){
        //if the type of wizard is 'fire', then print "this wizard shoots a fireball"
        //if the type is 'ice', then print "this wizard shoots an iceball"
        if(type.equals("fire")){
            System.out.println("this wizard shoots a fireball");
    } 
        else if(type.equals("ice")){
        System.out.println("this wizard shoots an iceball");
    } 
        else {
        System.out.println("invalid");
    }
}
}
    
public class Main {
     public static void main(String[] args) {

        //create a generic enemy and call its functions
        Enemy Enemy1 = new Enemy(100, 10);
        Enemy1.attack();

        // create a fire and an ice wizard and call all functions
        Wizard Wizard1 = new Wizard(100, 20, "fire");
        Wizard1.attack();
        Wizard1.damageType();

        Wizard Wizard2 = new Wizard(100, 20, "ice");
        Wizard2.attack();
        Wizard2.damageType();

        // create a goblin and call its functions
        Goblin goblin = new Goblin(100, 1);
        goblin.attack();
    }
}

